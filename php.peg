start = 
space* ("<" "?php" space*)? code:code_with_spaces* (space* "?>")? space*
{
  return new Code(code);
}

arguments = space* "(" first:expression? others:(space* ',' expression)* ")" space*
{
  expressions = [];
  if (typeof first !== 'undefined') {
    others = others.map(function(x) { return x[x.length - 1]; });
    expressions = [ first ].concat(others);
  }

  return new Arguments(expressions);
}

array_append = space* variable:variable & { return variable.index == '[]'; }
 space* "=" space* expression:expression space*
{
  return new Array_Append(variable, expression);
}

attribute = 
("public" / "private" / "protected" / "static" / space+)


block =
block_braces / block_simple

block_braces =
space* "{" space* code:code_with_spaces* "}" space*
{
  return new Block(code);
}

block_simple =
' '* '\n' ' '* code:code_with_meat space*
{
  return new Block(code);
}

code = 
  function_definition
/ comment
/ statement
/ class_definition
/ expression terminator
/ terminator

code_with_spaces =
  code
/ space+

code_with_meat = 
  code code_with_spaces*

comment = comment_line / comment_block

comment_line = "//" text:[^\n]*
{
  return new Comment(compress(text), 0);
}

comment_block = "/*"  text:(! "*/".)+ "*/"
{
  return new Comment(compress(text), 1);
}

exception_raise = 
"throw" expression:expression terminator
{
  return new Exception_Raise(expression);
}

expression =
  expression_list
/ expression2

expression2 = 
space* conversions:conversion* expression:(
  array_append
/ static_value
/ "new" invoke_function
/ invoke_static_member
/ invoke_method
/ invoke_variable_function
/ "new" invoke_variable_function
/ variable
/ create_array
/ modifier
/ invoke_function
/ comment
/ ("!" space* exp:expression2 { return create_expression(exp, true); } )
) space*
{
  return create_expression(expression, conversions);
}

static_value =
  value
/ string
/ number

expression_list = first:expression2
others:(space* op:operator exp:expression2 { return [ op, exp ]; })+ space*
{
  return new Expression_List([first].concat(others));
  var result = [];
  for (var i = 0; i < list.length; ++i) {
    if (list[i][0] !== null)
      result.push(list[i][0]);
  }
  
  return {
    type: 'expression_list',
    data: result,
    data2: list
  };
}

space = [ \n]
espace = [ \n] { return ''; }

class_block = space* "{" space*
code:(
  method_definition
/ comment
/ property
/ ';'
/ space+
)*
space* "}" space*
{
  return new Class_Block(code);
}

class_definition = "class" space+ name:non_keyword 
parent:(space+ "extends" space+ parent:non_keyword { return parent; })? block:class_block
{
  
  return new Class_Definition(compress(name), parent, block);
}

conversion =
space* "(" space* type:word space* ")" space*
{
  return new Conversion(type);
}

create_array = space* "array" arguments:arguments space*
{
  return new Create_Array(arguments);
}

foreach =
"foreach" space*
"(" space* object:variable space+ "as" space+ ("$" key:word space* "=>" space*)? value:variable space* ")"
block:block
{
  if (typeof key === 'undefined')
    key = '';

  return new Foreach_Object(object, compress(key), value, block);
}

function_definition = "function" space+ name:non_keyword parameters:parameters block:block
{
  return new Function_Definition(compress(name), parameters, block);
}

// The most tricky rule in this grammar.
heredoc =
space* "<<<" (label1:word "\n" { Parser.label = label1; return label1; })
text:(label2:(word / variable / .) ! { return label2 == Parser.label; })+
word space*
{
  text = text.map(function(x) { return x[0]});
  return new Literal_String(text, 'heredoc', Parser.label);
}

invoke_function = space* name:non_keyword arguments:arguments space*
{
  return new Invoke_Function(compress(name), arguments);
}

invoke_method = object:variable "->" method:invoke_function
{
  return new Invoke_Method(object, method);
}

invoke_static_member = class_name:word "::" target:(variable / invoke_function)
{
  return new Invoke_Static_Member(class_name, target);
}

invoke_variable_function = space* variable:variable arguments:arguments space*
{
  return new Invoke_Variable_Function(variable, arguments);
}

method_definition = attribute* "function" space+ name:non_keyword parameters:parameters block:block
{
  name = compress(name);
  var constructor = (name == '__construct');
  return new Method_Definition(name, parameters, block, constructor);
}

number = number:('-'? space* [0-9.]+)
{
  return compress(number);
}

default_value = space* "=" space* default_value:[^,)\n]+
{
  return compress(default_value);
}

parameter = "$" name:word default_value:default_value?
{
  if (typeof default_value === 'undefined')
    default_value = '';

  return new Parameter(compress(name), default_value);
}

parameters = space* "(" first:parameter? others:(space* ',' space* parameter)* ")" space*
{
  parameters = [];
  if (typeof first !== 'undefined') {
    others = others.map(function(x) { return x[x.length - 1]; });
    parameters = [ first ].concat(others);
  }

  return new Parameters(parameters);
}
property =
attribute+ name:variable value:(space* "=" space* expression+)? terminator
{
  value = value[value.length - 1];
  return new Property(name, value);
}

statement = 
  ("return" space+ expression? terminator)
/ do_while
/ control_no_parameters
/ control_with_parameters
/ exception_raise
/ foreach
/ switch

control_no_parameters =
space*
name:("else") space* block:block
space*
{
  return new Control(name, null, block);
}

do_while =
space* "do" block:block
"while" space* "(" expression:expression ")" terminator
{
  return new Control('do', expression, block);
}

control_with_parameters =
space*
name:(keyword_with_parameter) space* "(" condition:expression+ ")" block:block
space*
{
  return new Control(name, condition, block);
}

keyword_with_parameter = 
"if" / "else if" / "while"

string = single_quote / double_quote / heredoc
single_quote = "'" text:[^']* "'"
{ 
  return new Literal_String(compress(text), 'single');
}

double_quote = '"' text:[^"]* '"'
{ 
  return new Literal_String(compress(text), 'double');
}

value = 
"true"i / "false"i
/ "bool"i / "int"i / "float"i / "string"i
/ "null"i

assignment = 
variable:variable space* "=" space* expression:expression
{
  if (variable.index == '[]')
    return new Array_Append(variable, expression);
  else
    return new Assignment(variable, expression);
}

modifier_operators = "--" / "++"

modifier = 
(modifier_operators variable) /
(variable modifier_operators)

non_keyword = 
!keyword_with_parameter word

operator =
  symbol:(comparison_operator
/ action_operator)
{
  if (symbol == '.')
    symbol = '+';

  return new Operator(symbol);
}
  
comparison_operator = 
"===" / "==" / "=" / "!=" / "!==" /
"&&" / "||" /
">" / "<" / "<=" / ">="

action_operator = 
"+" / "-" / "." / "/" / "*"

comparison =
expression2 space* comparison_operator space* expression

switch =
space* "switch" space* "(" space* variable:variable space* ")" space* "{" space*
cases:(
space* "case" space* value:("(" space* variable:static_value space* ")" / variable:static_value
{ return variable; }) space* ":" space*
code:code
{ return new Case(value, code); }
)*
default_case:("default" space* ":" space* code:code { return code; })?
space* "}" space*
{
  return new Switch(variable, cases, default_case);
}

terminator = space* ';' space*
{
  return new Terminator();
}

word = word:[A-Za-z0-1_]+
{
  return word.join('');
}

variable = "$" root:word children:('->' word !(space* "("))*
index:("[" space* expression* space* "]")?
{
  return new Variable(compress(root), compress(children), compress(index));
}
